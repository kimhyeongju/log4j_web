package com.example.demo.api.vulnerability.controller;

import com.example.demo.api.vulnerability.service.VulnerabilityService;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import java.util.HashMap;
import java.util.Map;

/**
 * Log4j 취약점 실습 전용 컨트롤러
 * ⚠️ 교육 목적으로만 사용! 실제 운영 환경에서는 사용 금지
 */
@RestController
@RequestMapping("/api/vulnerable")
@RequiredArgsConstructor
@Log4j2
public class VulnerabilityController {

    private final VulnerabilityService vulnerabilityService;

    /**
     * 🚨 직접적인 Log4j 취약점 실습 엔드포인트
     * 사용자 입력을 필터링 없이 바로 로깅
     */
    @PostMapping("/log-input")
    public ResponseEntity<?> logUserInput(@RequestParam String input, HttpServletRequest request) {
        // 🚨 Log4j 취약점: 사용자 입력을 그대로 로깅
        log.info("Received user input: {}", input);
        
        vulnerabilityService.logUserInput(input, request);
        
        return ResponseEntity.ok("Input logged: " + input);
    }

    /**
     * 🚨 HTTP 헤더 로깅 실습
     * User-Agent에 JNDI 문자열 삽입 가능
     */
    @GetMapping("/log-headers")
    public ResponseEntity<?> logHeaders(HttpServletRequest request) {
        // 🚨 Log4j 취약점: HTTP 헤더 직접 로깅
        log.info("Logging all HTTP headers for request from: {}", request.getRemoteAddr());
        
        vulnerabilityService.logHttpHeaders(request);
        
        return ResponseEntity.ok("Headers logged successfully");
    }

    /**
     * 🚨 에러 로깅 실습
     * 에러 메시지에 사용자 입력 포함
     */
    @PostMapping("/cause-error")
    public ResponseEntity<?> causeError(@RequestParam String errorInput, HttpServletRequest request) {
        try {
            // 의도적으로 에러 발생
            if (errorInput.contains("error")) {
                throw new RuntimeException("User triggered error with input: " + errorInput);
            }
            
            return ResponseEntity.ok("No error occurred");
        } catch (Exception e) {
            // 🚨 Log4j 취약점: 에러 로깅에 사용자 입력 포함
            vulnerabilityService.logError(e.getMessage(), errorInput, request);
            return ResponseEntity.badRequest().body("Error occurred: " + e.getMessage());
        }
    }

    /**
     * 🚨 검색 패턴 분석 실습
     * 검색어에 특수 문자 및 JNDI 패턴 포함 가능
     */
    @GetMapping("/analyze-search")
    public ResponseEntity<?> analyzeSearchPattern(@RequestParam String searchTerm, HttpServletRequest request) {
        // 🚨 Log4j 취약점: 검색 패턴 분석 시 로깅
        log.info("Analyzing search pattern: {}", searchTerm);
        
        vulnerabilityService.analyzeSearchPattern(searchTerm, request);
        
        return ResponseEntity.ok("Search pattern analyzed: " + searchTerm);
    }

    /**
     * 🚨 파일 업로드 시뮬레이션
     * 파일명과 내용에 JNDI 문자열 포함 가능
     */
    @PostMapping("/upload-file")
    public ResponseEntity<?> uploadFile(@RequestParam String fileName, 
                                       @RequestParam String fileContent,
                                       HttpServletRequest request) {
        // 🚨 Log4j 취약점: 파일 정보 로깅
        log.info("File upload - Name: {}, Size: {}", fileName, fileContent.length());
        
        vulnerabilityService.logFileUpload(fileName, fileContent, request);
        
        return ResponseEntity.ok("File processed: " + fileName);
    }

    /**
     * 🚨 JNDI 공격 패턴 시뮬레이션 (교육용)
     * 실제 공격 패턴들을 로깅하여 취약점 시연
     */
    @PostMapping("/simulate-attack")
    public ResponseEntity<?> simulateJndiAttack(HttpServletRequest request) {
        // 🚨 실제 JNDI 공격 패턴들을 로깅
        log.warn("Starting JNDI attack simulation from IP: {}", request.getRemoteAddr());
        
        vulnerabilityService.simulateJndiAttack();
        
        return ResponseEntity.ok("JNDI attack patterns simulated. Check logs for details.");
    }

    /**
     * 🚨 실시간 공격 탐지 테스트
     */
    @PostMapping("/test-detection")
    public ResponseEntity<?> testAttackDetection(HttpServletRequest request) {
        // 🚨 Log4j 취약점: 탐지 테스트 요청 로깅
        log.info("Attack detection test requested from IP: {}, User-Agent: {}", 
                request.getRemoteAddr(), request.getHeader("User-Agent"));
        
        vulnerabilityService.detectRealTimeAttacks(request);
        
        return ResponseEntity.ok("Attack detection test completed");
    }

    /**
     * 🚨 사용자 정보 로깅 실습
     */
    @PostMapping("/log-user-info")
    public ResponseEntity<?> logUserInfo(@RequestParam String username,
                                        @RequestParam String email,
                                        @RequestParam(required = false) String additionalInfo,
                                        HttpServletRequest request) {
        // 🚨 Log4j 취약점: 사용자 정보를 그대로 로깅
        log.info("User info logging - Username: {}, Email: {}", username, email);
        
        vulnerabilityService.logUserInfo(username, email, additionalInfo, request);
        
        return ResponseEntity.ok("User information logged");
    }

    /**
     * 🚨 설정 값 조회 및 로깅
     */
    @GetMapping("/config")
    public ResponseEntity<?> getConfigValue(@RequestParam String configKey,
                                           @RequestParam String configValue,
                                           HttpServletRequest request) {
        // 🚨 Log4j 취약점: 설정 값을 그대로 로깅
        log.info("Configuration access - Key: {}, Value: {}", configKey, configValue);
        
        vulnerabilityService.logConfigurationValue(configKey, configValue, request);
        
        return ResponseEntity.ok(Map.of("key", configKey, "value", configValue));
    }

    /**
     * 🚨 데이터베이스 쿼리 로깅 시뮬레이션
     */
    @PostMapping("/log-query")
    public ResponseEntity<?> logDatabaseQuery(@RequestParam String query,
                                             @RequestParam String parameters,
                                             HttpServletRequest request) {
        // 🚨 Log4j 취약점: 쿼리와 파라미터를 그대로 로깅
        log.info("Database query logging - Query: {}, Params: {}", query, parameters);
        
        vulnerabilityService.logDatabaseQuery(query, parameters, request);
        
        return ResponseEntity.ok("Database query logged");
    }

    /**
     * 🚨 API 응답 로깅
     */
    @PostMapping("/log-response")
    public ResponseEntity<?> logApiResponse(@RequestParam String endpoint,
                                          @RequestParam String responseData,
                                          HttpServletRequest request) {
        // 🚨 Log4j 취약점: API 응답 데이터를 그대로 로깅
        log.info("API response logging - Endpoint: {}, Data: {}", endpoint, responseData);
        
        vulnerabilityService.logApiResponse(endpoint, responseData, request);
        
        return ResponseEntity.ok("API response logged");
    }

    /**
     * 🚨 세션 정보 로깅
     */
    @PostMapping("/log-session")
    public ResponseEntity<?> logSessionInfo(@RequestParam String sessionId,
                                          @RequestParam String sessionData,
                                          HttpServletRequest request) {
        // 🚨 Log4j 취약점: 세션 정보를 그대로 로깅
        log.info("Session logging - ID: {}, Data: {}", sessionId, sessionData);
        
        vulnerabilityService.logSessionInfo(sessionId, sessionData, request);
        
        return ResponseEntity.ok("Session information logged");
    }

    /**
     * 🚨 멀티 파라미터 로깅
     */
    @PostMapping("/log-multiple")
    public ResponseEntity<?> logMultipleInputs(@RequestParam Map<String, String> params,
                                              HttpServletRequest request) {
        // 🚨 Log4j 취약점: 여러 파라미터를 동시에 로깅
        params.forEach((key, value) -> log.info("Parameter - {}: {}", key, value));
        
        vulnerabilityService.logMultipleInputs(params, request);
        
        return ResponseEntity.ok("Multiple parameters logged: " + params.size() + " items");
    }

    /**
     * 🚨 JSON 페이로드 로깅
     */
    @PostMapping("/log-json")
    public ResponseEntity<?> logJsonPayload(@RequestBody Map<String, Object> payload,
                                           HttpServletRequest request) {
        // 🚨 Log4j 취약점: JSON 페이로드를 그대로 로깅
        log.info("JSON payload received: {}", payload);
        
        payload.forEach((key, value) -> {
            log.debug("JSON field - {}: {}", key, value);
        });
        
        return ResponseEntity.ok("JSON payload logged");
    }

    /**
     * 🚨 쿠키 정보 로깅
     */
    @GetMapping("/log-cookies")
    public ResponseEntity<?> logCookies(HttpServletRequest request) {
        // 🚨 Log4j 취약점: 쿠키 정보를 그대로 로깅
        if (request.getCookies() != null) {
            for (javax.servlet.http.Cookie cookie : request.getCookies()) {
                log.info("Cookie - {}: {}", cookie.getName(), cookie.getValue());
            }
        }
        
        return ResponseEntity.ok("Cookies logged");
    }

    /**
     * 🚨 URL 파라미터 로깅
     */
    @GetMapping("/log-url-params")
    public ResponseEntity<?> logUrlParams(@RequestParam(required = false) String param1,
                                         @RequestParam(required = false) String param2,
                                         @RequestParam(required = false) String param3,
                                         HttpServletRequest request) {
        // 🚨 Log4j 취약점: URL 파라미터를 개별적으로 로깅
        if (param1 != null) log.info("URL param1: {}", param1);
        if (param2 != null) log.info("URL param2: {}", param2);
        if (param3 != null) log.info("URL param3: {}", param3);
        
        // 전체 쿼리 스트링 로깅
        String queryString = request.getQueryString();
        if (queryString != null) {
            log.info("Full query string: {}", queryString);
        }
        
        return ResponseEntity.ok("URL parameters logged");
    }

    /**
     * 🔍 공격 패턴 목록 조회 (교육용)
     */
    @GetMapping("/attack-patterns")
    public ResponseEntity<?> getAttackPatterns() {
        String[] patterns = vulnerabilityService.getCommonAttackPatterns();
        
        Map<String, Object> response = new HashMap<>();
        response.put("patterns", patterns);
        response.put("count", patterns.length);
        response.put("warning", "These are for educational purposes only!");
        
        return ResponseEntity.ok(response);
    }

    /**
     * 🚨 폼 데이터 로깅
     */
    @PostMapping("/log-form")
    public ResponseEntity<?> logFormData(@RequestParam("username") String username,
                                        @RequestParam("password") String password,
                                        @RequestParam(value = "comment", required = false) String comment,
                                        HttpServletRequest request) {
        // 🚨 Log4j 취약점: 폼 데이터를 그대로 로깅
        log.info("Form submission - Username: {}, Password: {}, Comment: {}", 
                username, password, comment);
        
        // 🚨 추가적인 상세 로깅
        log.debug("Form data from IP {}: user='{}', pass='{}', comment='{}'", 
                getClientIpAddress(request), username, password, comment);
        
        return ResponseEntity.ok("Form data logged");
    }

    /**
     * 🚨 실시간 로그 스트리밍 시뮬레이션
     */
    @GetMapping("/stream-logs")
    public ResponseEntity<?> streamLogs(@RequestParam String data, HttpServletRequest request) {
        // 🚨 Log4j 취약점: 스트리밍 데이터를 실시간으로 로깅
        for (int i = 0; i < 5; i++) {
            log.info("Stream #{}: {}", i + 1, data);
            try {
                Thread.sleep(100); // 0.1초 간격
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
        
        return ResponseEntity.ok("Log streaming completed");
    }

    // 유틸리티 메서드
    private String getClientIpAddress(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        
        String xRealIp = request.getHeader("X-Real-IP");
        if (xRealIp != null && !xRealIp.isEmpty()) {
            return xRealIp;
        }
        
        return request.getRemoteAddr();
    }
}